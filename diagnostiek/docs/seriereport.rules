__author__ = "Martin Haagmans (https://github.com/zaag)"
__license__ = "MIT"


def write_list(listname, worksheet, row=0, col=0, skip=1, header=False,
               orientation='rows', format=None, formatheader=None):
    if header:
        worksheet.write(row, col, header, formatheader)
        row += skip

    if orientation == 'rows':
        [worksheet.write(row + i, col, ii, format)
         for i, ii in enumerate(listname)]
        row = row + len(listname) + 2

    elif orientation == 'cols':
        [worksheet.write(row, col + i, ii, format)
         for i, ii in enumerate(listname)]
        col = col + len(listname) + 2
        row += 1

    return (row, col)


def get_callable_for_report(dnr, target, db=None):
    if db is None:
        db = METRICSDB
    conn = sqlite3.connect(db)
    c = conn.cursor()

    total_sql = """SELECT REF_N, CALLABLE,
    NO_COVERAGE, LOW_COVERAGE, EXCESSIVE_COVERAGE
    FROM callable
    WHERE (SAMPLE='{s}' AND TARGET='{t}')
    """.format(s=dnr, t=target)

    callable_sql = """SELECT CALLABLE
    FROM callable
    WHERE (SAMPLE='{s}' AND TARGET='{t}')
    """.format(s=dnr, t=target)
    c.execute(total_sql)
    all_out = [val for tup in c.fetchall() for val in tup]

    c.execute(callable_sql)
    callable_out = [val for tup in c.fetchall() for val in tup]

    conn.close()

    return (sum(callable_out) / sum(all_out)) * 100


def get_perc_target_covered(dnr, target, serie, db=None):
    if db is None:
        db = METRICSDB
    conn = sqlite3.connect(db)
    c = conn.cursor()

    percentage = """SELECT ROUND(PERCENTAGE, 1)
    FROM procenttargetcovered
    WHERE (SAMPLE='{s}' AND TARGET='{t}' AND SERIE='{serie}')
    """.format(s=dnr, t=target, serie=serie)
    c.execute(percentage)
    return c.fetchone()[0]


def get_picard_for_report(dnr, db=None):
    if db is None:
        db = METRICSDB
    conn = sqlite3.connect(db)
    c = conn.cursor()
    alignsqlr1 = """SELECT DISTINCT round(MEAN_READ_LENGTH, 1)
                 FROM alignment
                 WHERE (SAMPLE='{}'
                 AND CATEGORY='FIRST_OF_PAIR')
                 """.format(dnr)

    alignsqlr2 = """SELECT DISTINCT round(MEAN_READ_LENGTH, 1)
                 FROM alignment
                 WHERE (SAMPLE='{}'
                 AND CATEGORY='SECOND_OF_PAIR')
                 """.format(dnr)

    hssql = """SELECT DISTINCT
            round(PCT_PF_UQ_READS*100),
            round(PCT_SELECTED_BASES*100),
            round(MEAN_TARGET_COVERAGE)
            FROM hsmetrics WHERE (SAMPLE='{}'
            AND SERIE='{}')
            """.format(dnr, serie)

    c.execute(alignsqlr1)
    readlength1 = [val for tup in c.fetchall() for val in tup]

    c.execute(alignsqlr2)
    readlength2 = [val for tup in c.fetchall() for val in tup]

    c.execute(hssql)
    hsmetrics = [val for tup in c.fetchall() for val in tup]
    conn.close()
    return readlength1 + readlength2 + hsmetrics


def read_sangerfile(f):
    sample, extension = os.path.splitext(os.path.split(f)[1])
    df = pd.read_csv(f, sep='\t', header=None)
    df.columns = ['gen', 'chrom', '{}_noncallablestart'.format(sample),
                  '{}_noncallableend'.format(sample), 'targetstart',
                  'targetend']
    df.set_index(['chrom', 'targetstart', 'targetend', 'gen'], inplace=True)
    return df, sample.split('.')[0]


rule seriereport:
    input:
        samplereports = expand(rules.samplereport.output, sample=samples),
        sangers = expand(rules.getsangers.output.sangers, sample=samples),
        snpchecks = expand(rules.duplicatesnpcheck.output.snpcomp, sample=samples),
        dupsnps = rules.comparesnpchecksserie.output

    output:
        "output/MS{}_report.xlsx".format(serie)
    message:
        "Creating excel file for serie."
    run:
        import glob
        db = METRICSDB
        writer = pd.ExcelWriter(output[0], engine='xlsxwriter')
        wb = writer.book
        wb.set_properties({
        'title':    serie,
        'subject':  'MiSEQUENCING',
        'author':   'Martin Haagmans',
        'comments': 'Created with Python and XlsxWriter'})
        ws1 = wb.add_worksheet('Metrics')

        headerformat = wb.add_format()
        headerformat.set_font_size(16)

        underlined = wb.add_format()
        underlined.set_bottom()

        INFO = ['Sample', 'Pakket', 'TypeA', 'R1', 'R2', '% PF UQ',
                '% OnTarget', 'Mean', '% > 30x']

        row1, col1 = write_list(INFO, ws1, format=underlined,
                                orientation='cols')

        for dnr in samples:
            pakket = input_dict[dnr]['pakket']
            panel = input_dict[dnr]['panel']
            if input_dict[dnr]['panel'] is None:
                perctargetcovered = 'nvt'
            elif input_dict[dnr]['panel'] is not None:
                perctargetcovered = get_perc_target_covered(dnr, pakket, serie)

            row1, col1 = write_list([dnr, pakket, panel] +
                                    get_picard_for_report(dnr) +
                                    [perctargetcovered],
                                    ws1, row=row1, orientation='cols')

        dflist = list()
        failed = list()

        for f in input.sangers:
            try:
                df, sample = read_sangerfile(f)
            except ValueError as e:
                pass
            else:
                if len(df.index) < 50:
                    dflist.append(df)
                elif len(df.index) >= 50:
                    failed.append('{}'.format(sample))

        if list() == dflist:
            ws2 = wb.add_worksheet('Sangers')
            row2, col2 = write_list(['Geen sangers'], ws2, orientation='cols')

        else:
            dfall = pd.concat(dflist, axis=1)
            dfall['max'], dfall['min'] = float('NaN'), float('NaN')

            for target in dfall.index:
                dfall.loc[target, 'max'] = dfall.loc[target].transpose().max()
                dfall.loc[target, 'min'] = dfall.loc[target].transpose().min()

            dfregions = dfall[['min', 'max']].astype(int).copy()
            dfregions['patients'] = ''

            for f in input.sangers:
                try:
                    df, sample = read_sangerfile(f)
                except ValueError as e:
                    pass
                else:
                    target = input_dict[sample]['pakket']
                    for i in df.join(dfregions).index:
                        if sample in failed:
                            continue
                        old = dfregions.loc[i]['patients']
                        dfregions.loc[i, 'patients'] = '{} {}:{}'.format(old, sample, target)

            dfregions.reset_index(inplace=True)
            dfregions['size'] = dfregions['max'] - dfregions['min']
            dfregions.drop(['targetstart', 'targetend'], axis=1, inplace=True)
            out = ['gen', 'chrom', 'min', 'max', 'size', 'patients']
            df = dfregions[out].copy()

            foo = lambda x: pd.Series([i for i in x.split()])
            split = df['patients'].apply(foo)
            df.drop('patients', axis=1, inplace=True)

            df.join(split.fillna('')).to_excel(writer, 'Sangers', header=False, index=False,
                                               startrow=1, startcol=0)


            ws2 = writer.sheets['Sangers']
            ws2.set_column('F:Z', 20)
            row2, col2 = write_list(out, ws2, row=0, orientation='cols',
                                    format=underlined)

        row1 += 2

        if list() != failed:
            ws1.write(row1, 0,
                      'De volgende patienten hebben >50 sangers: {}'.format(' '.join(failed)))
            row1 += 1

        if os.stat(input.dupsnps[0]).st_size == 0:
            ws1.write(row1, 0, 'Alle NGS-SNPchecks zijn uniek')
            row1 += 1

        elif os.stat(input.dupsnps[0]).st_size != 0:
            with open(input.dupsnps[0]) as f:
                for line in f:
                    ws1.write(row1, 0,
                              'De volgende patienten hebben dezelfde SNPcheck: {}'.format(line.strip()))
                    row1 += 1
        # row1 += 2
        notaqman = list()
        taqmanerror = list()

        for fn in input.snpchecks:
            count = 0
            sample_name = os.path.split(fn)[1].split('.')[0]

            if os.stat(fn).st_size == 0:
                notaqman.append(sample_name)
                continue

            with open (fn) as f:
                for line in f:
                    if 'NoTaqMan' in line :
                        count += 1
                    elif 'ERROR' in line:
                        if sample_name not in taqmanerror:
                            taqmanerror.append(sample_name)
            if count > 2:
                notaqman.append(sample_name)

        if len(notaqman) > 0:
            ws1.write(row1, 0, 'De volgende patienten hebben onvoldoende TaqMan calls: {}'.format(' '.join(notaqman)))
            row1 += 1

        if len(taqmanerror) > 0:
            ws1.write(row1, 0, 'De volgende patienten hebben afwijkende TaqMan calls: {}'.format(' '.join(taqmanerror)))
            row1 += 1


        writer.sheets['Metrics'] = ws1
        pd.concat([pd.read_csv(f, sep='\t', header=None, index_col=['locus', 'rsid'],
                   names=['locus', 'rsid', 'ngs', 'sanger',
                          f.split('/')[-1].split('.')[0]])
                  .drop(['ngs', 'sanger'], axis=1) for f in input.snpchecks], axis=1
                  ).reset_index().transpose().reset_index().fillna('NoInput').to_excel(writer, 'Metrics',
                                                                                         startrow=row1 + 3,
                                                                                         startcol=0,
                                                                                         header=False,
                                                                                         index=False)

        ws1.set_column('A:Z', 18)
        protect_options = {
                        'objects': False,
                        'scenarios': False,
                        'format_cells':          True,
                        'format_columns':        False,
                        'format_rows':           False,
                        'insert_columns':        False,
                        'insert_rows':           False,
                        'insert_hyperlinks':     False,
                        'delete_columns':        False,
                        'delete_rows':           False,
                        'select_locked_cells':   True,
                        'sort':                  False,
                        'autofilter':            False,
                        'pivot_tables':          False,
                        'select_unlocked_cells': True,
                    }
        ws2.protect(password = 'cerberus',
                    options = protect_options
                    )
        wb.close()
